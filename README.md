Короче, I2C - двунаправленный протокол связи, который даёт устройствам через 2 линии обмениваться данными (SCL и SDA). Принцип простейший master и slave побитово общаются друг с другом, синхронизируясь за счёт такта. SDA - обмен данным; SCL - такт. Уникальные адреса в нашем случае A4 (SDT) и A5(SCL). Глубже я сам хз, читал, но там сотсояния SCL чёто как-то хз короче..

Формула float normAy = (float)ay / 16384.0 - отдельный пиздец, короче, mpu6050 возвраащет данные в виде целых чисел (int16_t), они из себя представляют ускорение по осям в единицах LSB, по базе (Арсена Макаряна) чувствительность -+2g = -+32,768 (В 16-битном знаке) из этого говна, которое я сам уже подробно не изучал делаем вывод, что 1g = 16,384. Теперь для преоброзования знач. LSB в g юзаем формулу LSB/16,384. Я ненавижу как математику, так и физику.

А буфер - имба, тяжелее прогга, но говна творить не будет зато =)

p.s. arduino.cpp и arduinoNG.cpp - 2 разных подхода к буфферизации данных, классический - через last10 писал я, NG - писал знакомый из универа. В прод выпускаем NG, потому что там и правда более четкие данные и для той цели, к которой мы стремиимся подходит лучше, но чето мне подсказывает, что там не обошлось без chatGTP, но не планирую запариваться на этот счёт, чё есть - то есть.
baza.cs - это месяцы моей крови из жопы, и сотни часов гемплея в первобытного программиста, где я радовался любому получавшемуся результату.
hmelko.cs - я уже не помню, возможно, версия моего друга
verchu.exe - готовый первый файл собранный.
win.cs - кажется для проде уже юзали - пытались на нужной тачке собрать .exe 

Самое главое это то, что мы использовали Arduino nano + gy-521, без драйверов на порт и подключенном arduino ничего крутиться не будет. Конечно на выход собираем .exe со всем необходимым сразу, но сюда грузить это не буду. мне пох..
 
